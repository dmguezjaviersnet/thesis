\\\\
\textbf{Forward Selection}: FS es uno de los métodos de selección de características básicos. La idea como en otros métodos de selección de características, 
es seleccionar un subconjunto de características, que produce resultados lo suficientemente precisos en comparación con los resultados con todas las 
características. Forward selection comienza con 0 características en el modelo. La primera característica es seleccionada probando cada característica
que seleccionando la característica que devuelva por ejemplo la mejor clasificación o el mejor f-value  en tests estadísticos (ANOVA por ejemplo).   
\\\\
\textbf{Backward Selection}: Otro método de selección de características es \textbf{backward selection}, el cual es el proceso opuesto comparado con 
el \textbf{forward selection}. Mientras el forward selection comienza con 0 características, backward selection comienza con todas las características.
En cada paso el algoritmo testea todas las características que quedan y remueve la característica que menos aporta mal.
\\\\
\textbf{Genetic Algorithms}: Los algoritmos genéticos son un grupo de modelos computacionales para buscar soluciones potenciales a un problema en específico usando
una estructura de datos basadada en cromosomas, lo cual está inspirado en la evolución. Un cromosoma es una serie de instrucciones que un algoritmo puede usar para
construir un nuevo modelo o función, como un problema de optimización o seleccionar un subsconjunto de características para SVM. Todas las características serán 
representadas como un vector binario de tamaño m donde m es el número de características. \textbf{'1'} significa que la característica es parte del subconjunto y 
\textbf{'0'} que no lo es.  El algoritmo puede ser considerado como un proceso de dos etapas. Comienza con una población actual donde los mejores cromosomas son 
seleccionados para crear una población intermedia. Recombinación y mutación son aplicados para crear la nueva población. El proceso de dos etapas continúa una generación
en la ejecución del algoritmo genético.  El algoritmo comienza con una población inicial de cromosomas. Típicamente la población inicial se escoge de manera aleatoria 
del conjunto original de datos. Luego cada cromosoma es evaluado y se le asigna un fitness value. Los cromosomas que representen una mejor solución para el problema 
objetivo dan un mejor fitness value que aquellos cromosomas que dan una solución peor. Mejores fitness value significa mejores oportunidades de reproducir. EL proceso 
de reproducción puede ocurrir a través de crossover, mutation, o operaciones de reproducción. 
\\\\
\textbf{PCA}: PCA es otro método usado usado frecuentemente para la extracción de features. El PCA busca las componentes principales no correlacionadas que describen 
las dependencias entre múltiples variables. Las componente principales se ordenan de tal forma que la primera componente explique la mayor cantidad de varianza en los
datos, y la segunda componente para la segunda mayor cantidad de varianza y asi será.  Debe ser notado que forward selection, backward selection y genetic algorithm 
no afectan los datos, y solo son métodos para elejir la mejor combinación de características, pero PCA es para nuevas características. 


Fengyu Cong {\it et al.} [] para la extracción de \emph{features} descomponen la señal usando \textbf{WPD}(\emph{Wavelet Packet Decomposition}) usando
sucesivamente filtros de \emph{low-pass} y de \emph{high-pass}. Done WPD es llevado a cabo una aplicación iterativa de filtros espejos en cuadratura y seguido por
submuestreo. La selección de \emph{features} basada en machine learning puede ser asistida para reducir la demanda computacional para la clasificiación.
La selección de \emph{features} está diseñada para encontrar los \emph{features} que hacen una mejor discriminación de los baches y los segmentos
normales en estudio. Para la selección de \emph{features} se probaron con cuatro métodos: \textbf{Backward Selection}, \textbf{Forward Selection},
\textbf{Genetic Algorithm} y \textbf{PCA} usando un número diferente de \emph{features} seleccionados. \textbf{PCA} fue el que mejores resutados arrojó
cuando el número de \emph{features} es mayor que 5, mientras \textbf{FS}(\emph{Forward Selection}) es mejor cuando el número de \emph{features} es mayor
que 2 y menor que 6. \\
Para la clasificicación usaron \textbf{SVM} one-class classification con kernel RBF con parámetros  $\nu = 0.01$  $\gamma = 0.00002$. \textbf{SVM} fué
entrenado con el 70\%  de los datos (1234 segmentos) y el conjunto de entrenamiento fue escogido de manera aleatoria. El resto de los datos  (530 segmentos)
y en todos los 21 segmentos de anomalías fueron usados para los tests de precisión del modelo \textbf{SVM} construido. 

\cite{zheng2020fused} se refieren a que la mayoría de los artículos con respecto al tema no toman en consideración el hecho que la gran mayoría de la
carretera está en el mundo no posee anomalías, y que la aplicación de técnicas de Machine Learning utizando una ventana deslizante a ciegas puede
disminuir considerablemente la precisión y la rapidez del proceso de entrenamiento. Para esto plantean que una anomalía comienza con una señal normal
y luego ocurre un pico de aceleración en el eje Z que excede un \emph{threshold} superior y luego cae y excede un \emph{threshold} inferior o viceversa,
y finalmente la señal vuelve a estabilizarse entre esos dos \emph{threshold}s. Ese intervalo es el que consideran como el intervalo candidato en el que
puede haber una anomalía , y para encontrarlo utilizan primero el método heurístico de establecer un \emph{threshold} superior e inferior en la aceleración
y buscan el primer instante donde la aceleración sobrepasa alguno de los \emph{threshold}s y el último instante, y utilizan un método para encontrar los
instantes de tiempo justo antes de que ocurriera el primer evento y el instante de tiempo justo después de que ocurriera el último evento, de esta forma
logran construir una ventana de tamaño dinámico que contiene toda la información acerca de la anomalía, de esta forma construyen un conjunto de ventanas
con posibles anomalías en la serie temporal. Luego crean un modelo con un random forest utilizando algunos \emph{features} estadísticos de cada una de las ventanas
para filtrar ventanas que no constituyen anomalías reales, también proponen tratar al vehículo como un modelo de vibración de un nivel de libertad para lo
cual diseñan varios experimentos. Como resultado de esto llegaron a la conclusión de que la varianza de la aceleración en el eje Z cuando el vehículo interactúa
con una anomalía tendrá una relación casi lineal con la profundidad o altura de la anomalía. Utilizando \textbf{KNN} y \textbf{DTW}(\emph{Dynamic Time Warping}
que se utiliza para determinar similitud entre 2 series temporales que puedan ser obtenidas a distintas velocidades), es que llevan a cabo el proceso
de identificar los tipos de anomalías. Los autores comparan su propuesta con otras hechas en los últimos 3 años obteniendo un mejor \emph{F1 score} al
identifar los 3 tipos de anomalías que consideraron en cada uno de los 3 \emph{data sets} que probaron.
